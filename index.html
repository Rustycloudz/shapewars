<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Wars: Endless Siege</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        body {
            font-family: 'Chakra Petch', monospace;
            /* Page Background (Futuristic image) */
            background-color: #9FA9B7; 
            background-image: url('https://raw.githubusercontent.com/Rustycloudz/images/main/level_1.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed; 
            /* ------------------------------- */
            color: #48437A;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        /* REVISED: Removed ad-specific styling from content wrapper to center the game only */
        #content-wrapper { 
            width: 100%;
            max-width: 800px; /* Keeps the game centered */
        }
        #game-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(83, 79, 130, 0.42);
            background-color: #ADB4BD;
            position: relative; 
        }
        #gameCanvas {
            border-radius: 10px;
            background-color: #1f242e; /* Fallback color */
            display: block;
            touch-action: none; 
            cursor: crosshair;
        }
        .hud-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 20px;
            background-color: #6E458C;
            border-radius: 0 0 10px 10px;
            border-top: 4px solid #81A765;
            flex-wrap: wrap; 
        }
        .hud-item {
            font-size: 1.1rem;
            font-weight: 700;
            color: #59B360;
            text-shadow: 0 0 5px rgba(129, 167, 101, 0.31);
            margin: 5px 0;
        }
        .control-button {
            background-color: #2a3c4f;
            color: #00ffff;
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px #00aaff;
            transition: all 0.1s;
        }
        .control-button:active {
            box-shadow: 0 1px #00aaff;
            transform: translateY(3px);
        }
        .health-bar-container {
            width: 150px;
            height: 18px;
            background-color: #444;
            border-radius: 9px;
            overflow: hidden;
            border: 1px solid #00ffff;
        }
        #playerHealthBar {
            height: 100%;
            background: linear-gradient(90deg, #ff0077, #ff99aa);
            transition: width 0.3s;
        }
        
        /* --- OVERLAY STYLES --- */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 12px;
            z-index: 10;
        }

        #gameBriefingScreen {
            background-image: url('https://github.com/Rustycloudz/images/raw/main/General.png');
            background-size: cover;
            background-position: center;
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
        }
        
        #gameOverScreen {
            background: rgba(0, 0, 0, 0.85);
            display: none; 
        }

        .briefing-box {
            background-color: rgba(22, 27, 34, 0.9); 
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            max-width: 90%;
        }

        .briefing-box h2 {
            font-size: 2rem;
            color: #ffcc00;
            margin-bottom: 15px;
            text-shadow: 0 0 5px #ffcc00;
        }

        .briefing-box p {
            font-size: 1.1rem;
            color: #ffffff;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        /* --- AD STYLES (FIXED POSITION) --- */
        #ad-container {
            position: fixed; /* Adheres to viewport */
            bottom: 20px;    /* Bottom right */
            right: 20px;
            width: 350px;    /* Increased size */
            max-height: 600px;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(83, 79, 130, 0.42);
            background-color: #222; 
            z-index: 100; /* Ensure it is above game elements */
        }
        
        /* NEW AD CONTAINER STYLES (Bottom Left) */
        #ad-container-left {
            position: fixed; 
            bottom: 20px;    
            left: 20px; /* Position change */
            width: 350px; /* Same size as the right ad */
            max-height: 600px;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(83, 79, 130, 0.42);
            background-color: #222; 
            z-index: 100; 
        }

        #ad-container img, #ad-container-left img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
        }
        
        /* Responsive adjustments for smaller screens: Hide ads to prevent game overlap on small devices */
        @media (max-width: 700px) { 
            #ad-container, #ad-container-left {
                display: none;
            }
        }
        
        /* -------------------------- */
        
        .score-item {
            color: #ffcc00;
            margin: 5px 0;
        }
        .stat-display {
            font-size: 0.9rem;
            margin-right: 10px;
            padding: 2px 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <h1 class="text-3xl font-bold mb-4 text-cyan-400">SHAPE WARS: ENDLESS SIEGE</h1>

    <div id="content-wrapper">
        <div id="game-container" class="relative">
            
            <div id="gameBriefingScreen" class="overlay-screen">
                <div class="briefing-box">
                    <h2 class="text-4xl">ENDLESS SIEGE BRIEFING</h2>
                    <p>
                        The Pink Circle threat is now sector-wide, and there is no escape. Eliminate the hostiles for as long as you can across the **massive battleground**. Every **10 kills** an **Omega Core** will be deployed.
                    </p>
                    <p>
                        The siege is endless. Your mission is to survive, rack up a massive score, and set a new **High Score** before your inevitable destruction.
                    </p>
                    <button class="control-button text-xl px-8 py-3" onclick="startGame()">DEPLOY</button>
                </div>
            </div>
            
            <div id="gameOverScreen" class="overlay-screen">
                <h2 class="text-5xl font-extrabold text-red-500 mb-6 neon-text" style="text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;">GAME OVER</h2>
                <div id="finalScore" class="text-3xl text-white mb-4"></div>
                <div id="highScoreText" class="text-xl text-yellow-400 mb-6"></div>
                <button class="control-button text-xl px-8 py-3" onclick="restartGame()">RESTART</button>
            </div>
            
            <canvas id="gameCanvas"></canvas>

            <div class="hud-panel">
                <div class="flex items-center space-x-2">
                    <span class="text-white">HP:</span>
                    <div class="health-bar-container">
                        <div id="playerHealthBar"></div>
                    </div>
                </div>
                <div class="hud-item">Score: <span id="scoreDisplay">0</span></div>
                
                <div class="hud-item flex items-center">
                    <span class="text-white mr-2">Stats:</span>
                    <span id="fireRateDisplay" class="stat-display bg-green-800/50">Rate: 25</span>
                    <span id="defenseDisplay" class="stat-display bg-red-800/50">Def: 0%</span>
                    <span id="multiShotDisplay" class="stat-display bg-pink-800/50">Shots: 1</span>
                    <span id="sizeDisplay" class="stat-display bg-yellow-800/50">Size: 1x</span>
                    <span id="waveDisplay" class="stat-display bg-orange-800/50">Diff: 1.0x</span> 
                </div>
                
                <div id="bossHealthContainer" class="w-full mt-2 hidden">
                    <div class="text-center text-white text-lg font-bold">BOSS DETECTED: <span id="bossName">Omega Core</span></div>
                    <div class="health-bar-container w-full h-6 bg-gray-900 border-2 border-red-500">
                        <div id="bossHealthBar" class="h-full" style="width: 100%; background: linear-gradient(90deg, #ff0000, #ff8800);"></div>
                    </div>
                </div>

                <div class="hud-item">Lives: <span id="livesDisplay">3</span></div>
                <div class="hud-item">Enemies: <span id="enemyCount">0</span></div>
                <div class="hud-item">Kills: <span id="killCountDisplay">0</span></div>
            </div>
        </div>
    </div>
    
    <div id="ad-container">
    <p><em><strong>USE CODE "BEOLTK" AT SIGN-UP TO GET 500 SATOSHIS TOTALLY FREE!</strong></em></p>
        <a href="https://www.speed.app/" target="_blank">
            <img src="https://github.com/Rustycloudz/images/raw/main/rusty%40pc_lightning_ad.jpg" alt="Advertisement: Rusty's PC Lightning - Fast, Furious, and Fully Charged!" />
        </a>
    </div>
    <div id="ad-container-left">
    <P><em><strong>WE HAVE AMAZON AFFILIATION, SO SHOPPING WITH US HELPS!</strong></em></P>
        <a href="https://amzn.to/3X5cWaR" target="_blank">
            <img src="https://github.com/Rustycloudz/images/raw/main/drone.png" alt="Advertisement: Drone Tech - Automated Defense Systems" />
        </a>
    </div>
    <div class="mt-4 text-center text-sm">
        <p>Move: **W A S D** or **Arrow Keys** | Shoot: **Mouse Click**</p>
    </div>

    <audio id="shootSound" src="https://www.myinstants.com/media/sounds/pistol-shot.mpd" preload="auto"></audio>
    <audio id="hurtSound" src="https://www.myinstants.com/media/sounds/bonk_7zPAD7C.mp3" preload="auto"></audio>
    <audio id="contactSound" src="https://www.myinstants.com/media/sounds/screaming-goat.mp3" preload="auto"></audio>
    <audio id="powerupSound" src="https://www.myinstants.com/media/sounds/bruh-sound-effect_WstdzdM.mp3" preload="auto"></audio>
    <audio id="deathSound" src="https://www.myinstants.com/media/sounds/uuhhh_iqsgYFh.mp3" preload="auto"></audio>
    <script>
        // --- LOCAL STORAGE FUNCTIONS (No Change) ---
        window.saveHighScore = function (currentScore, currentKills) {
            const existingScoreData = localStorage.getItem('shapeRoyaleHighScore');
            let existingHighScore = { score: 0, kills: 0 };
            
            if (existingScoreData) {
                try {
                    existingHighScore = JSON.parse(existingScoreData);
                } catch(e) { console.error("Error parsing high score from localStorage:", e); }
            }
            if (currentScore > existingHighScore.score) {
                const newHighScore = { score: currentScore, kills: currentKills };
                localStorage.setItem('shapeRoyaleHighScore', JSON.stringify(newHighScore));
            }
        };

        window.getHighScore = function () {
            const scoreData = localStorage.getItem('shapeRoyaleHighScore');
            if (scoreData) {
                try {
                    return JSON.parse(scoreData);
                } catch(e) { console.error("Error parsing high score from localStorage:", e); return null; }
            }
            return null;
        };

        // --- GAME LOGIC ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const defenseDisplay = document.getElementById('defenseDisplay');
        const multiShotDisplay = document.getElementById('multiShotDisplay');
        const sizeDisplay = document.getElementById('sizeDisplay');
        const fireRateDisplay = document.getElementById('fireRateDisplay');
        const waveDisplay = document.getElementById('waveDisplay'); 
        const enemyCountDisplay = document.getElementById('enemyCount');
        const healthBar = document.getElementById('playerHealthBar');
        const killCountDisplay = document.getElementById('killCountDisplay');
        const livesDisplay = document.getElementById('livesDisplay'); 
        
        // References to the overlays
        const gameBriefingScreen = document.getElementById('gameBriefingScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreText = document.getElementById('finalScore');
        const highScoreText = document.getElementById('highScoreText');
        const gameOverTitle = document.querySelector('#gameOverScreen h2');
        
        // BOSS HUD elements
        const bossHealthContainer = document.getElementById('bossHealthContainer');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const bossNameDisplay = document.getElementById('bossName');
        
        // Reference to the audio elements
        const shootSound = document.getElementById('shootSound');
        const hurtSound = document.getElementById('hurtSound');
        const contactSound = document.getElementById('contactSound');
        const powerupSound = document.getElementById('powerupSound');
        const deathSound = document.getElementById('deathSound');

        // Game Constants
        let gameActive = false;
        
        // LIVES VARIABLE
        let playerLives = 3; 

        // WORLD/CAMERA CONSTANTS
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 500;
        const WORLD_WIDTH = 4000;
        const WORLD_HEIGHT = 4000;
        let cameraX = 0; 
        let cameraY = 0;
        
        let score = 0;
        let kills = 0; 
        
        let mouseX_Screen = CANVAS_WIDTH / 2; 
        let mouseY_Screen = CANVAS_HEIGHT / 2;
        let mouseX_World = WORLD_WIDTH / 2; 
        let mouseY_World = WORLD_HEIGHT / 2;
        
        const keys = {};
        
        // Global arrays for Obstacles
        const obstacles = [];
        
        // Game/Enemy Spawning Constants
        const MAX_OBSTACLES = 40; 
        const MAX_ENEMIES = 50; 
        let difficultyFactor = 1.0; 
        let difficultyTimer = 0;
        const DIFFICULTY_INCREASE_RATE = 600; 
        let ENEMY_SPAWN_RATE_BASE = 140; 
        const POWERUP_SPAWN_RATE = 300; 
        let enemySpawnTimer = 0;
        let powerupSpawnTimer = 0;
        
        // BOSS CONSTANTS/VARIABLES
        const BOSS_KILL_THRESHOLD = 10;
        let killsSinceLastBoss = 0;
        let bossesDefeatedCount = 0; 
        let currentBoss = null; 

        // NEW ENEMY WAVE STATE
        let currentEnemyShapeSides = 0; // 0: circle, 8: octagon, 4: square, 3: triangle
        let currentEnemyColor = '#ff0077';
        let currentEnemyBaseDamage = 5; 
        let currentEnemyBaseHealth = 20; 
        // END NEW ENEMY WAVE STATE

        // Background Image for Tiling
        const backgroundTile = new Image();
        backgroundTile.src = 'https://cdn.pixabay.com/photo/2013/07/25/11/50/dirt-166708_1280.png'; 
        const TILE_SIZE = 128; 

        // Canvas Setup 
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            const containerWidth = container.clientWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = (containerWidth / aspectRatio) + 'px';
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // --- COLLISION HELPER FUNCTIONS (No Change) ---
        function checkCircleRectCollision(circle, rect) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            const distX = circle.x - closestX;
            const distY = circle.y - closestY;
            const distance = Math.hypot(distX, distY);
            return distance < circle.radius;
        }

        function preventMovementThroughRect(shape, rect) {
            const closestX = Math.max(rect.x, Math.min(shape.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(shape.y, rect.y + rect.height));

            const distX = shape.x - closestX;
            const distY = shape.y - closestY;

            const distance = Math.hypot(distX, distY);
            
            if (distance < shape.radius) {
                const overlap = shape.radius - distance;
                const angle = Math.atan2(distY, distX);
                shape.x += Math.cos(angle) * overlap;
                shape.y += Math.sin(angle) * overlap;
            }
        }
        // --- END COLLISION HELPERS ---
        
        // Draw a tiled background with parallax effect
        function drawBackground() {
            const PARALLAX_FACTOR = 0.3; 
            
            const bgOffsetX = cameraX * PARALLAX_FACTOR;
            const bgOffsetY = cameraY * PARALLAX_FACTOR;
            
            const startX = Math.floor(bgOffsetX / TILE_SIZE) * TILE_SIZE;
            const startY = Math.floor(bgOffsetY / TILE_SIZE) * TILE_SIZE;
            
            const renderOffsetX = bgOffsetX % TILE_SIZE;
            const renderOffsetY = bgOffsetY % TILE_SIZE;
            
            for (let x = -renderOffsetX - TILE_SIZE; x < CANVAS_WIDTH + TILE_SIZE; x += TILE_SIZE) {
                for (let y = -renderOffsetY - TILE_SIZE; y < CANVAS_HEIGHT + TILE_SIZE; y += TILE_SIZE) {
                    if (backgroundTile.complete && backgroundTile.naturalWidth !== 0) {
                        ctx.drawImage(backgroundTile, x, y, TILE_SIZE, TILE_SIZE);
                    } else {
                        ctx.fillStyle = '#1f242e';
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }


        // --- ENTITY CLASSES ---
        class Shape {
            constructor(x, y, radius, color, health) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.health = health; this.maxHealth = health;
                this.velocity = { x: 0, y: 0 }; this.speed = 3;
            }
            draw() {
                // Default draw is a circle
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            takeDamage(damage) {
                const reduction = player ? player.defense / 100 : 0;
                this.health -= damage * (1 - reduction);
            }
            isDead() { return this.health <= 0; }
            update() { this.x += this.velocity.x; this.y += this.velocity.y; }
        }

        class Player extends Shape {
            constructor(x, y) {
                // Player Health is 500 (INCREASED FROM 250)
                super(x, y, 15, '#00ffff', 500); 
                this.fireRate = 25; 
                this.fireCooldown = 0;
                this.defense = 0; 
                this.bulletSizeModifier = 1.0; 
                this.multiShotCount = 1;
                this.speed = 4; 
                this.waveShotAmplitude = 0; 
            }
            handleInput() { 
                this.velocity.x = 0; this.velocity.y = 0;
                if (keys['w'] || keys['arrowup']) { this.velocity.y = -this.speed; }
                if (keys['a'] || keys['arrowleft']) { this.velocity.x = -this.speed; }
                if (keys['d'] || keys['arrowright']) { this.velocity.x = this.speed; }
                if (keys['s'] || keys['arrowdown']) { this.velocity.y = this.speed; }
                
                if (this.velocity.x !== 0 && this.velocity.y !== 0) {
                    this.velocity.x *= 0.707; this.velocity.y *= 0.707;
                }
            }
            
            draw() {
                super.draw(); 
                
                // Motion trail/thrust effect
                if (this.velocity.x !== 0 || this.velocity.y !== 0) {
                    const thrustSize = 5;
                    const angle = Math.atan2(-this.velocity.y, -this.velocity.x); 
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.radius, 0); 
                    ctx.lineTo(-this.radius - thrustSize * 2, thrustSize); 
                    ctx.lineTo(-this.radius - thrustSize * 2, -thrustSize); 
                    ctx.closePath();
                    
                    ctx.fillStyle = `rgba(0, 255, 255, ${Math.min(1, Math.hypot(this.velocity.x, this.velocity.y) / this.speed)})`; 
                    ctx.fill();
                    ctx.restore();
                }

                // Turret 
                const angle = getAngle(this.x, this.y, mouseX_World, mouseY_World);
                const barrelLength = this.radius * 1.5; 
                const barrelWidth = 6; 

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);

                ctx.fillStyle = "#000000"; 
                ctx.fillRect(this.radius - 2, -barrelWidth / 2, barrelLength, barrelWidth); 

                ctx.restore();
            }

            update() {
                super.update();
                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y)); 
            }
            updateHUD() {
                const percentage = (this.health / this.maxHealth) * 100;
                healthBar.style.width = `${Math.max(0, percentage)}%`;
                healthBar.style.background = percentage > 50 ? 'linear-gradient(90deg, #00ff77, #00ffff)' : 'linear-gradient(90deg, #ff99aa, #ff0077)';
            }
            takeDamage(damage) {
                const reduction = this.defense / 100;
                this.health -= damage * (1 - reduction);
            }
        }

        class Enemy extends Shape {
            // Added sides and baseDamage
            constructor(x, y, radius = 12, color = '#ff0077', health = 20, sides = 0, baseDamage = 5) { 
                const initialHealth = health * difficultyFactor;
                const initialSpeed = 1.8 * Math.min(2.0, difficultyFactor); 
                const initialRadius = radius * Math.min(1.5, Math.sqrt(difficultyFactor));
                
                super(x, y, initialRadius, color, initialHealth); 
                this.speed = initialSpeed; 
                this.fireRate = 80 / difficultyFactor; 
                this.fireCooldown = Math.random() * this.fireRate;
                
                this.bulletSizeModifier = 1.0;
                this.multiShotCount = 1;
                this.waveShotAmplitude = 0;
                this.sides = sides; // Stored the sides count
                this.baseDamage = baseDamage; // Stored base damage
            }
            
            draw() {
                if (this.sides <= 0) {
                    // Draw circle (default)
                    super.draw(); 
                    return;
                }

                // Draw polygon (Octagon, Square, Triangle, etc.)
                ctx.beginPath();
                const numSides = this.sides;
                // Add a slight rotation to center polygons visually
                // Triangles look best when pointed up (0 rotation) or with a slight offset.
                const rotation = numSides === 3 ? -Math.PI / 2 : Math.PI / numSides; 
                
                for (let i = 0; i < numSides; i++) {
                    const angle = (i / numSides) * Math.PI * 2 + rotation;
                    const x = this.x + this.radius * Math.cos(angle);
                    const y = this.y + this.radius * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fillStyle = this.color; 
                ctx.fill();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            chase(target) {
                const angle = getAngle(this.x, this.y, target.x, target.y);
                this.velocity.x = Math.cos(angle) * this.speed;
                this.velocity.y = Math.sin(angle) * this.speed;
            }
            aiShoot(target) {
                this.fireCooldown--;
                if (this.fireCooldown <= 0) {
                    const angle = getAngle(this.x, this.y, target.x, target.y);
                    const baseBulletSpeed = 5 * Math.min(1.5, difficultyFactor);
                    const baseBulletRadius = 5;
                    const baseDamage = this.baseDamage * difficultyFactor; // Use stored baseDamage

                    const finalRadius = baseBulletRadius * this.bulletSizeModifier;
                    const finalDamage = baseDamage * this.bulletSizeModifier;

                    for (let i = 0; i < this.multiShotCount; i++) {
                        const spreadAngle = 0.1 * (i - (this.multiShotCount - 1) / 2);
                        
                        projectiles.push(new Projectile(
                            this.x, 
                            this.y, 
                            angle + spreadAngle, 
                            baseBulletSpeed, 
                            finalRadius, 
                            'enemy', 
                            this.color, // Use enemy color for bullets
                            finalDamage,
                            this.waveShotAmplitude 
                        ));
                    }
                    this.fireCooldown = this.fireRate + (Math.random() * 30 - 15);
                }
            }
            update(target) {
                this.chase(target); 
                this.aiShoot(target); 
                super.update();
            }
        }
        
        class BossEnemy extends Enemy {
            // MODIFIED: Takes a bossId to determine type
            constructor(x, y, bossId) { 
                const baseHealth = 500;
                const baseRadius = 40;
                const baseSpeed = 2.5; 

                const scaledHealth = baseHealth * difficultyFactor * 0.5; 
                const scaledRadius = baseRadius * Math.min(2, Math.sqrt(difficultyFactor)); 
                const scaledSpeed = baseSpeed * Math.min(1.5, Math.sqrt(difficultyFactor));
                
                let bossColor, bossSides, bossName, bulletColor;
                
                // --- NEW BOSS CYCLE LOGIC (3-Boss rotation) ---
                if (bossId % 3 === 1) { 
                    // Boss 1: Purple Circle (Omega Core)
                    bossColor = '#8A2BE2'; // BlueViolet
                    bossSides = 0; // Circle
                    bossName = "Omega Core";
                    bulletColor = '#ff00ff';
                } else if (bossId % 3 === 2) { 
                    // Boss 2: Orange Octagon (Octo Sentinel)
                    bossColor = '#ffa500'; // Orange
                    bossSides = 8; // Octagon
                    bossName = "Octo Sentinel";
                    bulletColor = '#ff4500'; 
                } else { // 3rd, 6th, 9th... 
                    // Boss 3: Purple Square (Chrono Cube) - NEW
                    bossColor = '#6A0DAD'; // Dark Purple
                    bossSides = 4; // Square
                    bossName = "Chrono Cube"; 
                    bulletColor = '#9400D3'; // Darker Purple bullet
                }
                // --- END NEW BOSS CYCLE LOGIC ---
                
                // Boss uses a higher base damage (8) regardless of shape, but scaled by difficulty
                super(x, y, scaledRadius, bossColor, scaledHealth, bossSides, 8); 
                this.speed = scaledSpeed; 
                this.fireRate = 40; 
                this.bulletSizeModifier = 1.5;
                this.multiShotCount = 3;
                this.waveShotAmplitude = 2; 
                this.name = bossName;
                this.bulletColor = bulletColor; 
            }
            
            aiShoot(target) {
                this.fireCooldown--;
                if (this.fireCooldown <= 0) {
                    const angle = getAngle(this.x, this.y, target.x, target.y);
                    const baseBulletSpeed = 6 * 2.0; // Hardcoded boss speed modifier
                    const baseBulletRadius = 5;
                    const baseDamage = this.baseDamage * 1.5 * difficultyFactor; // Boss damage calculation

                    const finalRadius = baseBulletRadius * this.bulletSizeModifier;
                    const finalDamage = baseDamage * this.bulletSizeModifier;

                    const totalShots = 5; 
                    for (let i = 0; i < totalShots; i++) {
                        const spreadAngle = 0.2 * (i - (totalShots - 1) / 2);
                        
                        projectiles.push(new Projectile(
                            this.x, 
                            this.y, 
                            angle + spreadAngle, 
                            baseBulletSpeed, 
                            finalRadius, 
                            'enemy', 
                            this.bulletColor, // Use boss's specific bullet color
                            finalDamage,
                            this.waveShotAmplitude 
                        ));
                    }
                    this.fireCooldown = this.fireRate + (Math.random() * 50);
                }
            }

            updateBossHealthBar() {
                const percentage = (this.health / this.maxHealth) * 100;
                bossHealthBar.style.width = `${Math.max(0, percentage)}%`;
            }
        }

        class Projectile extends Shape {
            constructor(x, y, angle, speed, radius, type, color, damage, waveAmplitude = 0) {
                super(x, y, radius, color, 1);
                this.damage = damage; 
                this.speed = speed; 
                this.type = type; 
                
                this.waveAmplitude = waveAmplitude; 
                this.travelDistance = 0; 
                
                this.baseVelocityX = Math.cos(angle) * speed; 
                this.baseVelocityY = Math.sin(angle) * speed;
                
                this.perpendicularAngle = angle + Math.PI / 2;
                
                if (waveAmplitude === 0) {
                    this.velocity.x = this.baseVelocityX;
                    this.velocity.y = this.baseVelocityY;
                }
            }

            update() {
                if (this.waveAmplitude > 0) {
                    this.travelDistance += this.speed;
                    
                    const amplitude = this.waveAmplitude * 3; 
                    const waveOffset = Math.sin(this.travelDistance / 25) * amplitude; 
                    
                    const perpX = Math.cos(this.perpendicularAngle) * waveOffset;
                    const perpY = Math.sin(this.perpendicularAngle) * waveOffset;
        
                    this.x += this.baseVelocityX + perpX;
                    this.y += this.baseVelocityY + perpY;

                } else {
                    super.update();
                }
            }
        }

        class Powerup {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 10;
                const types = ['HealthPack', 'MultiShot', 'BulkShot', 'DefenseBoost', 'FireRateBoost', 'WaveShot'];
                this.type = types[Math.floor(Math.random() * types.length)];
                this.color = this.getColor();
            }
            getColor() {
                switch (this.type) {
                    case 'BulkShot': return '#ffcc00';
                    case 'MultiShot': return '#ff00ff';
                    case 'HealthPack': return '#00aaff';
                    case 'DefenseBoost': return '#ff4444';
                    case 'FireRateBoost': return '#00ff00'; 
                    case 'WaveShot': return '#ff8800';
                    default: return '#cccccc';
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                
                const r = this.radius;

                if (this.type === 'HealthPack') {
                    const hx = this.x; 
                    const hy = this.y; 
                    
                    ctx.beginPath();
                    ctx.moveTo(hx, hy + r * 1.2);
                    ctx.bezierCurveTo( hx + r * 1.5, hy - r * 0.5, hx + r * 0.5, hy - r * 1.5, hx, hy - r * 0.5 );
                    ctx.bezierCurveTo( hx - r * 0.5, hy - r * 1.5, hx - r * 1.5, hy - r * 0.5, hx, hy + r * 1.2 );
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                } else if (this.type === 'MultiShot') {
                    const size = r * 0.3; 
                    const length = r * 2; 
                    const x_start = this.x - r;
                    const y_start = this.y - r;

                    ctx.beginPath();
                    ctx.rect(x_start, this.y - size, length, size * 2); 
                    ctx.rect(this.x - size, y_start, size * 2, length); 
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                
                } else if (this.type === 'BulkShot') {
                    const ax = this.x;
                    const ay = this.y;
                    
                    ctx.beginPath();
                    ctx.moveTo(ax, ay - r);
                    ctx.lineTo(ax - r, ay + r / 2);
                    ctx.lineTo(ax + r, ay + r / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                } else if (this.type === 'WaveShot') {
                    const startX = this.x - r;
                    const endX = this.x + r;
                    const halfR = r / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, this.y);
                    ctx.bezierCurveTo( this.x - halfR, this.y - r, this.x + halfR, this.y + r, endX, this.y );
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 5; 
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3; 
                    ctx.stroke();
                    ctx.lineCap = 'butt'; 
                    
                } else if (this.type === 'FireRateBoost') {
                    const len = r * 1.8; 
                    const halfLen = len / 2;
                    
                    ctx.lineCap = 'round';
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    for(let i = 0; i < 3; i++){
                        ctx.rotate(Math.PI / 3 * i); 
                        
                        ctx.beginPath();
                        ctx.moveTo(-halfLen, 0);
                        ctx.lineTo(halfLen, 0);
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 5; 
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(-halfLen, 0);
                        ctx.lineTo(halfLen, 0);
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 3; 
                        ctx.stroke();
                    }

                    ctx.restore();
                    ctx.lineCap = 'butt'; 
                    
                } else if (this.type === 'DefenseBoost') {
                    const sx = this.x;
                    const sy = this.y;
                    const sr = r * 1.5; 
                    
                    ctx.beginPath();
                    ctx.moveTo(sx - sr * 0.8, sy - sr * 1.0); 
                    ctx.lineTo(sx + sr * 0.8, sy - sr * 1.0);
                    ctx.quadraticCurveTo( sx + sr * 1.0, sy + sr * 0.0, sx + sr * 0.5, sy + sr * 1.0 );
                    ctx.lineTo(sx, sy + sr * 1.5);
                    ctx.lineTo(sx - sr * 0.5, sy + sr * 1.0);
                    ctx.quadraticCurveTo( sx - sr * 1.0, sy + sr * 0.0, sx - sr * 0.8, sy - sr * 1.0 );
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }
        }

        class Obstacle {
            constructor(x, y, width, height, color = '#343a40') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color; 
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
        // --- END ENTITY CLASSES ---

        let player;
        let enemies = [];
        let projectiles = [];
        let powerups = [];

        // Function called from the "DEPLOY" button
        window.startGame = function() {
            gameBriefingScreen.style.display = 'none';
            initGame();
            gameActive = true;
            requestAnimationFrame(gameLoop);
        }
        
        function generateRandomObstacles() {
            obstacles.length = 0;
            const numObstacles = MAX_OBSTACLES; 
            
            for (let i = 0; i < numObstacles; i++) {
                const width = Math.random() * 100 + 30; 
                const height = Math.random() * 100 + 30; 
                
                let x, y;
                let validPosition = false;
                const minDistanceToCenter = 150; 
                const worldCenterX = WORLD_WIDTH / 2;
                const worldCenterY = WORLD_HEIGHT / 2;
                
                while (!validPosition) {
                    x = Math.random() * (WORLD_WIDTH - width);
                    y = Math.random() * (WORLD_HEIGHT - height);
                    
                    const obsCenterX = x + width / 2;
                    const obsCenterY = y + height / 2;
                    
                    if (Math.hypot(obsCenterX - worldCenterX, obsCenterY - worldCenterY) > minDistanceToCenter) {
                        validPosition = true;
                    }
                }
                
                obstacles.push(new Obstacle(x, y, width, height));
            }
        }

        function initGame() {
            player = new Player(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
            enemies = [];
            projectiles = [];
            powerups = [];
            score = 0;
            kills = 0;
            difficultyFactor = 1.0;
            difficultyTimer = 0;
            enemySpawnTimer = 0;
            powerupSpawnTimer = 0;
            
            // Boss Reset
            currentBoss = null;
            killsSinceLastBoss = 0;
            bossesDefeatedCount = 0; 
            bossHealthContainer.style.display = 'none';
            
            // LIVES RESET
            playerLives = 3; 
            
            // NEW ENEMY STATE RESET (Default: Pink Circle)
            currentEnemyShapeSides = 0; 
            currentEnemyColor = '#ff0077';
            currentEnemyBaseDamage = 5;
            currentEnemyBaseHealth = 20;
            // END NEW ENEMY STATE RESET

            gameOverScreen.style.display = 'none';

            player.defense = 0;
            player.bulletSizeModifier = 1.0;
            player.multiShotCount = 1;
            player.fireRate = 25; 
            player.waveShotAmplitude = 0;

            generateRandomObstacles();

            updateHUD();
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
        }

        function updateHUD() {
            scoreDisplay.textContent = score;
            enemyCountDisplay.textContent = enemies.length;
            killCountDisplay.textContent = kills; 
            
            livesDisplay.textContent = playerLives; 
            
            fireRateDisplay.textContent = `Rate: ${player.fireRate}`; 
            
            defenseDisplay.textContent = `Def: ${player.defense}%`;
            multiShotDisplay.textContent = `Shots: ${player.multiShotCount}`;
            sizeDisplay.textContent = `Size: ${player.bulletSizeModifier.toFixed(1)}x`;
            waveDisplay.textContent = `Diff: ${difficultyFactor.toFixed(1)}x`;
            player.updateHUD();

            if (currentBoss) {
                currentBoss.updateBossHealthBar();
            }
        }

        function spawnEnemy() { 
            if (enemies.length >= MAX_ENEMIES) return; 
            
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const padding = 50;
            
            switch (side) {
                case 0: 
                    x = cameraX + Math.random() * CANVAS_WIDTH; 
                    y = cameraY - padding; 
                    break;
                case 1: 
                    x = cameraX + Math.random() * CANVAS_WIDTH; 
                    y = cameraY + CANVAS_HEIGHT + padding; 
                    break;
                case 2: 
                    x = cameraX - padding; 
                    y = cameraY + Math.random() * CANVAS_HEIGHT; 
                    break;
                case 3: 
                    x = cameraX + CANVAS_WIDTH + padding; 
                    y = cameraY + Math.random() * CANVAS_HEIGHT; 
                    break;
            }
            
            x = Math.max(0, Math.min(WORLD_WIDTH, x));
            y = Math.max(0, Math.min(WORLD_HEIGHT, y));
            
            // Use current wave state for new enemies
            enemies.push(new Enemy(
                x, 
                y, 
                12, 
                currentEnemyColor, 
                currentEnemyBaseHealth, 
                currentEnemyShapeSides, 
                currentEnemyBaseDamage 
            ));
        }
        
        function spawnBoss() {
            if (currentBoss) return; 

            let spawnX, spawnY;
            const padding = 100;

            switch (Math.floor(Math.random() * 4)) {
                case 0: // Top
                    spawnX = cameraX + CANVAS_WIDTH / 2;
                    spawnY = cameraY - padding;
                    break;
                case 1: // Bottom
                    spawnX = cameraX + CANVAS_WIDTH / 2;
                    spawnY = cameraY + CANVAS_HEIGHT + padding;
                    break;
                case 2: // Left
                    spawnX = cameraX - padding;
                    spawnY = cameraY + CANVAS_HEIGHT / 2;
                    break;
                case 3: // Right
                    spawnX = cameraX + CANVAS_WIDTH + padding;
                    spawnY = cameraY + CANVAS_HEIGHT / 2;
                    break;
            }
            
            spawnX = Math.max(100, Math.min(WORLD_WIDTH - 100, spawnX));
            spawnY = Math.max(100, Math.min(WORLD_HEIGHT - 100, spawnY));
            
            const nextBossId = bossesDefeatedCount + 1; 
            currentBoss = new BossEnemy(spawnX, spawnY, nextBossId); 
            enemies.push(currentBoss);

            bossHealthContainer.style.display = 'block';
            bossNameDisplay.textContent = currentBoss.name;
            currentBoss.updateBossHealthBar();
        }

        function spawnPowerup() {
            const x = cameraX + Math.random() * CANVAS_WIDTH;
            const y = cameraY + Math.random() * CANVAS_HEIGHT;
            powerups.push(new Powerup(x, y));
        }

        function fireWeapon() {
            if (player.fireCooldown > 0) return;
            shootSound.currentTime = 0; shootSound.play().catch(e => console.log("Audio play prevented:", e));
            
            const angle = getAngle(player.x, player.y, mouseX_World, mouseY_World);
            const baseBulletSpeed = 8; const baseBulletRadius = 5; const baseDamage = 12; 
            const finalRadius = baseBulletRadius * player.bulletSizeModifier;
            const finalDamage = baseDamage * player.bulletSizeModifier;
            
            for (let i = 0; i < player.multiShotCount; i++) {
                const spreadAngle = 0.1 * (i - (player.multiShotCount - 1) / 2);
                
                projectiles.push(new Projectile(
                    player.x, 
                    player.y, 
                    angle + spreadAngle, 
                    baseBulletSpeed, 
                    finalRadius, 
                    'player', 
                    '#ffffff', 
                    finalDamage,
                    player.waveShotAmplitude
                ));
            }
            player.fireCooldown = player.fireRate;
        }
        
        function playHurtSound() { hurtSound.currentTime = 0; hurtSound.play().catch(e => console.log("Audio play prevented:", e)); }
        function playContactSound() { contactSound.currentTime = 0; contactSound.play().catch(e => console.log("Audio play prevented:", e)); }
        function playPowerupSound() { powerupSound.currentTime = 0; powerupSound.play().catch(e => console.log("Audio play prevented:", e)); }
        function playDeathSound() { deathSound.currentTime = 0; deathSound.play().catch(e => console.log("Audio play prevented:", e)); }

        function checkCollision(objA, objB) {
            const distance = Math.hypot(objA.x - objB.x, objA.y - objB.y);
            return distance < objA.radius + objB.radius;
        }

        function handleCollisions() {
            
            // --- Player and Enemies vs Powerups (Logic unchanged) ---
            powerups = powerups.filter(powerup => {
                
                if (checkCollision(player, powerup)) {
                    playPowerupSound();
                    
                    switch (powerup.type) {
                        case 'HealthPack': player.health = Math.min(player.maxHealth, player.health + 40); break;
                        case 'MultiShot': player.multiShotCount += 1; break;
                        case 'BulkShot': player.bulletSizeModifier = Math.min(4.0, player.bulletSizeModifier + 0.3); break;
                        case 'DefenseBoost': player.defense = Math.min(80, player.defense + 5); break;
                        case 'FireRateBoost': player.fireRate = Math.max(5, player.fireRate - 2); break;
                        case 'WaveShot': player.waveShotAmplitude = Math.min(10, player.waveShotAmplitude + 1); break;
                    }
                    updateHUD();
                    return false; 
                }

                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    if (checkCollision(enemy, powerup)) {
                        playPowerupSound();
                        
                        switch (powerup.type) {
                            case 'HealthPack': 
                                enemy.health = enemy.maxHealth; 
                                break;
                            case 'MultiShot': 
                                enemy.multiShotCount = Math.min(5, enemy.multiShotCount + 1); 
                                break;
                            case 'BulkShot': 
                                enemy.bulletSizeModifier = Math.min(3.0, enemy.bulletSizeModifier + 0.3);
                                enemy.radius = Math.min(30, enemy.radius + 2);
                                enemy.maxHealth += 10;
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + 10);
                                break;
                            case 'DefenseBoost': 
                                enemy.maxHealth += 30;
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + 30);
                                enemy.color = '#8b0000'; 
                                break;
                            case 'FireRateBoost': 
                                enemy.fireRate = Math.max(10, enemy.fireRate - 10);
                                break;
                            case 'WaveShot':
                                enemy.waveShotAmplitude = Math.min(5, enemy.waveShotAmplitude + 1);
                                break;
                        }
                        return false; 
                    }
                }

                return true; 
            });
            
            // Projectiles vs Obstacles (Logic unchanged) 
            projectiles = projectiles.filter(p => {
                let destroyedByWall = false;
                
                for (const obstacle of obstacles) {
                    if (checkCircleRectCollision(p, obstacle)) {
                        destroyedByWall = true;
                        break;
                    }
                }
                return !destroyedByWall;
            });
            
            // Player Projectiles vs Enemies (Updated for Boss logic)
            projectiles = projectiles.filter(p => {
                if (p.type === 'player') {
                    let hit = false;
                    enemies = enemies.filter(enemy => {
                        if (checkCollision(p, enemy)) {
                            enemy.takeDamage(p.damage);
                            hit = true;
                            if (enemy.isDead()) {
                                score += 100 * difficultyFactor; 
                                kills++; 
                                
                                // Boss kill check logic
                                if (enemy instanceof BossEnemy) {
                                    currentBoss = null;
                                    bossHealthContainer.style.display = 'none';
                                    killsSinceLastBoss = 0; // Reset counter for the next boss
                                    score += 5000; // Large bonus for defeating the boss
                                    
                                    // Grant +1 Life upon Boss Defeat
                                    playerLives = Math.min(99, playerLives + 1); 
                                    
                                    bossesDefeatedCount++; // INCREMENT BOSS DEFEAT COUNT
                                    
                                    if (bossesDefeatedCount === 1) { 
                                        // WAVE 2: Orange Octagons (After Boss 1)
                                        currentEnemyShapeSides = 8; 
                                        currentEnemyColor = '#ffa500'; 
                                        currentEnemyBaseDamage = 7;
                                        currentEnemyBaseHealth = 30;
                                    } else if (bossesDefeatedCount === 2) {
                                        // WAVE 3: Purple Squares (After Boss 2)
                                        currentEnemyShapeSides = 4; // Square
                                        currentEnemyColor = '#6A0DAD'; // Dark Purple
                                        currentEnemyBaseDamage = 10;
                                        currentEnemyBaseHealth = 45;
                                    } else if (bossesDefeatedCount === 3) {
                                        // WAVE 4: Yellow Triangles (After Boss 3)
                                        currentEnemyShapeSides = 3; // Triangle
                                        currentEnemyColor = '#ffff00'; // Yellow
                                        currentEnemyBaseDamage = 15; // Increase base damage
                                        currentEnemyBaseHealth = 60; // Increase base health
                                    } else { 
                                        // WAVE 5, 6, 7... (After Boss 4, 5, 6...)
                                        // Cycle back to a stronger version of Wave 1/Circles, and increase base stats significantly
                                        currentEnemyShapeSides = 0; 
                                        currentEnemyColor = '#ff0077'; // Revert to pink/red circle color
                                        currentEnemyBaseDamage += 5; // Significant permanent damage increase
                                        currentEnemyBaseHealth += 20; // Significant permanent health increase
                                    }
                                    
                                    playDeathSound();
                                    return false;
                                } else {
                                    killsSinceLastBoss++; // Increment only for non-boss enemies
                                }
                                
                                playDeathSound();
                                return false;
                            }
                        }
                        return true;
                    });
                    return !hit;
                }
                return true;
            });

            // Enemy Projectiles vs Player (Logic unchanged)
            projectiles = projectiles.filter(p => {
                if (p.type === 'enemy' && checkCollision(p, player)) {
                    player.takeDamage(p.damage); playHurtSound();
                    return false;
                }
                return true;
            });

            // Player vs Enemies (Contact damage - Logic unchanged)
            enemies.forEach(enemy => {
                if (checkCollision(player, enemy)) {
                    const damageBefore = player.health;
                    player.takeDamage(0.5 * difficultyFactor); 
                    if (player.health < damageBefore) { playContactSound(); }
                }
            });

            // Projectiles cleanup (Logic unchanged)
            const OFF_SCREEN_BUFFER = 50; 
            projectiles = projectiles.filter(p =>
                p.x > 0 - OFF_SCREEN_BUFFER && p.x < WORLD_WIDTH + OFF_SCREEN_BUFFER && 
                p.y > 0 - OFF_SCREEN_BUFFER && p.y < WORLD_HEIGHT + OFF_SCREEN_BUFFER
            );
        }

        function endGame() {
            gameActive = false;
            gameOverScreen.style.display = 'flex';
            
            gameOverScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
            gameOverTitle.textContent = 'GAME OVER';
            gameOverTitle.style.textShadow = '0 0 10px #ff0000, 0 0 20px #ff0000';
            
            window.saveHighScore(score, kills);
            const highScore = window.getHighScore();

            finalScoreText.innerHTML = `
                <div class="score-item">FINAL SCORE: <span class="text-3xl">${score}</span></div>
                <div class="score-item">ENEMIES KILLED: ${kills}</div>
            `;
            
            if (highScore && highScore.score > 0) {
                if (score === highScore.score) {
                    highScoreText.innerHTML = `<div class="text-2xl mt-4 text-green-400">NEW HIGH SCORE: ${score}</div><div class="text-lg">Kills: ${highScore.kills}</div>`;
                } else {
                    highScoreText.innerHTML = `<div class="text-2xl mt-4">HIGH SCORE: ${highScore.score}</div><div class="text-lg">Most Kills: ${highScore.kills}</div>`;
                }
            } else {
                 highScoreText.textContent = "Your first score is recorded locally!";
            }
        }

        window.restartGame = function() {
            initGame();
            gameActive = true;
            requestAnimationFrame(gameLoop);
        }
        
        function updateCamera() {
            // Center the camera on the player
            cameraX = player.x - CANVAS_WIDTH / 2;
            cameraY = player.y - CANVAS_HEIGHT / 2;

            // Clamp the camera to the world boundaries
            cameraX = Math.max(0, cameraX);
            cameraY = Math.max(0, cameraY);
            cameraX = Math.min(cameraX, WORLD_WIDTH - CANVAS_WIDTH);
            cameraY = Math.min(cameraY, WORLD_HEIGHT - CANVAS_HEIGHT);
        }
        
        function drawWorldBoundary() {
            ctx.strokeStyle = '#FF0000'; 
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }

        function gameLoop() {
            if (!gameActive) return; 

            // 1. Clear Canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // 2. Update Camera
            updateCamera();

            // 3. Draw Background (No context translation applied here for parallax)
            drawBackground();

            // 4. Apply Camera Translation for all World Objects
            ctx.save();
            ctx.translate(-cameraX, -cameraY);
            
            // 5. Update Timers and Difficulty
            difficultyTimer++;
            if (difficultyTimer > DIFFICULTY_INCREASE_RATE) {
                difficultyFactor += 0.1; 
                ENEMY_SPAWN_RATE_BASE = Math.max(50, ENEMY_SPAWN_RATE_BASE - 5); 
                difficultyTimer = 0;
            }
            
            // Boss Spawn Check
            if (!currentBoss && killsSinceLastBoss >= BOSS_KILL_THRESHOLD) {
                spawnBoss();
            }

            enemySpawnTimer++;
            // Only spawn regular enemies if no boss, or keep a minimum number of enemies with the boss present
            const maxEnemies = currentBoss ? 15 : MAX_ENEMIES;
            const currentSpawnRate = ENEMY_SPAWN_RATE_BASE / Math.min(2.0, difficultyFactor); 
            if (enemySpawnTimer > currentSpawnRate) { 
                if (enemies.length < maxEnemies) {
                    spawnEnemy();
                }
                enemySpawnTimer = 0;
            }
            
            powerupSpawnTimer++;
            if (powerupSpawnTimer > POWERUP_SPAWN_RATE) {
                spawnPowerup();
                powerupSpawnTimer = 0;
            }

            // 6. Update Entities
            player.handleInput();
            player.update();
            player.fireCooldown = Math.max(0, player.fireCooldown - 1); 

            enemies.forEach(enemy => enemy.update(player));
            projectiles.forEach(p => p.update());

            // Resolve Player/Enemy movement against obstacles
            [player, ...enemies].forEach(entity => {
                obstacles.forEach(obstacle => {
                    preventMovementThroughRect(entity, obstacle);
                });
            });

            // 7. Handle Collisions
            handleCollisions();

            // 8. Check Game Over / Respawn
            if (player.isDead()) {
                playerLives--;
                
                if (playerLives <= 0) {
                    ctx.restore(); 
                    endGame();
                    return;
                } else {
                    // Respawn logic: reset health and position
                    player.health = player.maxHealth;
                    // Teleport player back to the center of the current screen view
                    player.x = cameraX + CANVAS_WIDTH / 2;
                    player.y = cameraY + CANVAS_HEIGHT / 2;
                    
                    // Clear nearby hostile projectiles for a moment of safety
                    projectiles = projectiles.filter(p => p.type !== 'enemy' || Math.hypot(p.x - player.x, p.y - player.y) > 300);
                    
                    updateHUD(); // Update the lives and health display
                }
            }
            
            // 9. Draw Entities
            powerups.forEach(p => p.draw());
            obstacles.forEach(o => o.draw()); 
            player.draw();
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            
            drawWorldBoundary();

            // 10. Restore context
            ctx.restore(); 

            // 11. Update HUD
            updateHUD();

            // 12. Loop
            requestAnimationFrame(gameLoop);
        }

        // --- EVENT LISTENERS ---

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
                e.preventDefault();
            }
            keys[key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            mouseX_Screen = (e.clientX - rect.left) * scaleX;
            mouseY_Screen = (e.clientY - rect.top) * scaleY;
            
            mouseX_World = mouseX_Screen + cameraX;
            mouseY_World = mouseY_Screen + cameraY;
        });

        canvas.addEventListener('mousedown', () => {
            if (gameActive) {
                fireWeapon();
            }
        });

        // Initial setup only shows the briefing screen
        window.onload = function() {
            resizeCanvas();
        }
    </script>

</body>
</html>
